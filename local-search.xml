<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>NumPy库入门</title>
    <link href="/2024/04/30/20240430_numPy/"/>
    <url>/2024/04/30/20240430_numPy/</url>
    
    <content type="html"><![CDATA[<p>掌握表示、清洗、统计和展示数据的能力</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>NumPy是一个开源的Python科学计算基础库。</p><ul><li>一个强大的N维数组对象ndarray</li><li>广播功能函数</li><li>整合C/C++/Fortran代码的工具</li><li>线性代数、傅里叶变换、随机数生成等功能</li></ul><p>Numpy是SciPy、Pandas等数据处理或科学计算库的基础。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#引用</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><h1 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h1><h2 id="数据的维度"><a href="#数据的维度" class="headerlink" title="数据的维度"></a>数据的维度</h2><p>从一个数据到一组数据，一个数据表达一个含义，一组数据表达一个或多个含义。维度是一组数据的组织形式。数据之间的关系。</p><h3 id="一维数据"><a href="#一维数据" class="headerlink" title="一维数据"></a>一维数据</h3><p>由对等关系的有序或无序数据构成，采用线性方式组织。（对应<strong>列表</strong>、数组和<strong>集合</strong>等概念）</p><h4 id="列表和数组"><a href="#列表和数组" class="headerlink" title="列表和数组"></a>列表和数组</h4><p>一组数据的有序结构，区别：</p><p>列表：数据类型可以不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">3.14</span>,<span class="hljs-string">&#x27;pi&#x27;</span>,<span class="hljs-number">3.1404</span>,[<span class="hljs-number">3.1401</span>,<span class="hljs-number">3.1349</span>],<span class="hljs-string">&#x27;3.1376&#x27;</span><br></code></pre></td></tr></table></figure><p>数组：数据型相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">3.1413</span>，<span class="hljs-number">3.1313</span>，<span class="hljs-number">3.1234</span>，<span class="hljs-number">3.1451</span>，<span class="hljs-number">3.5161</span><br></code></pre></td></tr></table></figure><h3 id="二维数据"><a href="#二维数据" class="headerlink" title="二维数据"></a>二维数据</h3><p>二维数据由多个一维数据构成,是一维数据的组合形式。</p><div class="table-container"><table><thead><tr><th>排名</th><th>学校</th><th>总分</th></tr></thead><tbody><tr><td>1</td><td>清华</td><td>100.0</td></tr><tr><td>2</td><td>北大</td><td>99.8</td></tr><tr><td>3</td><td>浙大</td><td>98.8</td></tr></tbody></table></div><h3 id="多维数据"><a href="#多维数据" class="headerlink" title="多维数据"></a>多维数据</h3><p>多维数据由一维或二维数据在新维度扩展形成。<strong>2023-&gt;2024，时间维度</strong>。</p><div class="table-container"><table><thead><tr><th>排名</th><th>学校</th><th>总分</th></tr></thead><tbody><tr><td>1</td><td>清华</td><td>100.0</td></tr><tr><td>2</td><td>北大</td><td>99.8</td></tr><tr><td>3</td><td>浙大</td><td>98.8</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>排名</th><th>学校</th><th>总分</th></tr></thead><tbody><tr><td>1</td><td>清华</td><td>100.0</td></tr><tr><td>2</td><td>北大</td><td>99.6</td></tr><tr><td>3</td><td>浙大</td><td>98.7</td></tr></tbody></table></div><h3 id="高维数据"><a href="#高维数据" class="headerlink" title="高维数据"></a>高维数据</h3><p>高维数据仅仅利用最基本的二元关系展示数据间的复杂结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<br><span class="hljs-string">&quot;firstName&quot;</span>:<span class="hljs-string">&quot;Tian&quot;</span>,<br><span class="hljs-string">&quot;lastName&quot;</span>:<span class="hljs-string">&quot;Song&quot;</span>,<br><span class="hljs-string">&quot;address&quot;</span>:&#123;<br><span class="hljs-string">&quot;streetAddr&quot;</span>:<span class="hljs-string">&quot;中关村南大街5号&quot;</span>,<br><span class="hljs-string">&quot;city&quot;</span>:<span class="hljs-string">&quot;北京市&quot;</span>,<br><span class="hljs-string">&quot;zipcode&quot;</span>:<span class="hljs-string">&quot;1000081&quot;</span><br>&#125;,<br><span class="hljs-string">&quot;prof&quot;</span>:[<span class="hljs-string">&quot;Computer System&quot;</span>,<span class="hljs-string">&quot;Security&quot;</span>]<br>&#125;<br><span class="hljs-comment">#键值对组织</span><br><span class="hljs-comment">#没有数据规整的组织方式，却有数据间的包含关系、数据间的并列关系以及数据间的属性关系等，形成了数据的组织方式</span><br></code></pre></td></tr></table></figure><h3 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#一维数据</span><br>[<span class="hljs-number">3.1413</span>，<span class="hljs-number">3.1313</span>，<span class="hljs-number">3.1234</span>，<span class="hljs-number">3.1451</span>，<span class="hljs-number">3.5161</span>]有序、列表<br>&#123;<span class="hljs-number">3.1413</span>，<span class="hljs-number">3.1313</span>，<span class="hljs-number">3.1234</span>，<span class="hljs-number">3.1451</span>，<span class="hljs-number">3.5161</span>&#125;无序、集合<br><br><span class="hljs-comment">#二维数据</span><br>[[<span class="hljs-number">3.1413</span>，<span class="hljs-number">3.1313</span>，<span class="hljs-number">3.1234</span>],<br> [<span class="hljs-number">3.1234</span>，<span class="hljs-number">3.1451</span>，<span class="hljs-number">3.5161</span>]]列表<br><br><span class="hljs-comment">#多维数据</span><br>列表<br><br><span class="hljs-comment">#高维数据</span><br>字典类型或数据表示格式(JSON、XML和YAML格式)<br><span class="hljs-built_in">dict</span> = &#123;<br>    <span class="hljs-string">&quot;firstName&quot;</span>:<span class="hljs-string">&quot;Tian&quot;</span>,<br>    <span class="hljs-string">&quot;lastName&quot;</span>:<span class="hljs-string">&quot;Song&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组对象-ndarray"><a href="#数组对象-ndarray" class="headerlink" title="数组对象:ndarray"></a>数组对象:ndarray</h2><p>例：计算$A^2+B^2$，其中，A和B是一维数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pySum</span>():<br>a = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>b = [<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>]<br>c = []<br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):<br>c.append(a[i]**<span class="hljs-number">2</span> + b[i]**<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">return</span> c<br><br><span class="hljs-built_in">print</span>(pySum())<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">npSum</span>():<br>a = np.array([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>b = np.array([<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>])<br><br>c = a**<span class="hljs-number">2</span> + b**<span class="hljs-number">3</span><br><br><span class="hljs-keyword">return</span> c<br><br><span class="hljs-built_in">print</span>(npSum())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>分析工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随记</title>
    <link href="/2024/04/29/20240429_daliylogs/"/>
    <url>/2024/04/29/20240429_daliylogs/</url>
    
    <content type="html"><![CDATA[<p>—-小甲鱼爬虫</p><p>—-python菜鸟速成</p><p>—-Python面向对象编程五步曲-从零到就业</p><p>—-机器学习基础-吴恩达</p><p>—-统计学习方法-李航</p><p>—-慕课北理工np，pandas…</p><p>—-图像处理与机器学习</p><p>—-唐宇迪opencv</p><p>—-斯坦福李飞飞计算机视觉</p><p>—-学习标注自己的数据集</p><p>—-mmdetection</p><p>—-光纤类课程</p><p>—-数据库</p><p>—-信号处理</p>]]></content>
    
    
    <categories>
      
      <category>感悟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>成长</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小甲鱼爬虫</title>
    <link href="/2024/04/22/20240422_crawler/"/>
    <url>/2024/04/22/20240422_crawler/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>网络爬虫（又称为<a href="https://baike.baidu.com/item/网页蜘蛛/15696186?fromModule=lemma_inlink">网页蜘蛛</a>，网络机器人，在<a href="https://baike.baidu.com/item/FOAF/4916497?fromModule=lemma_inlink">FOAF</a>社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取<a href="https://baike.baidu.com/item/万维网/215515?fromModule=lemma_inlink">万维网</a>信息的<a href="https://baike.baidu.com/item/程序/13831935?fromModule=lemma_inlink">程序</a>或者<a href="https://baike.baidu.com/item/脚本/1697005?fromModule=lemma_inlink">脚本</a>。另外一些不常使用的名字还有蚂蚁、<a href="https://baike.baidu.com/item/自动索引/56622668?fromModule=lemma_inlink">自动索引</a>、<a href="https://baike.baidu.com/item/模拟程序/12726595?fromModule=lemma_inlink">模拟程序</a>或者蠕虫。</p><h2 id="场景分类"><a href="#场景分类" class="headerlink" title="场景分类"></a>场景分类</h2><ul><li>通用爬虫：抓取系统重要组成部分。抓取的是一整张页面数据。</li><li>聚焦爬虫：建立在通用爬虫基础上。抓取的是页面中特定的局部内容。</li><li>增量式爬虫：检测网站中数据更新的情况。只会抓取最新更新出来的数据。</li></ul><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="robots-txt协议"><a href="#robots-txt协议" class="headerlink" title="robots.txt协议"></a>robots.txt协议</h2><p>robots是告诉搜索引擎，你可以爬取收录我的什么页面，你不可以爬取和收录我的那些页面。robots很好的控制网站那些页面可以被爬取，那些页面不可以被爬取。</p><p><strong>主流的搜索引擎都会遵守robots协议</strong>。并且robots协议是爬虫爬取网站第一个需要爬取的文件。爬虫爬取robots文件后，会读取上面的协议，并准守协议爬取网站，收录网站。</p><p><strong>robots文件是一个纯文本文件，也就是常见的.txt文件</strong>。在这个文件中网站管理者可以声明该网站中不想被robots访问的部分，或者指定搜索引擎只收录指定的内容。因此，robots的优化会直接影响到搜索引擎对网站的收录情况。</p><img src="/2024/04/22/20240422_crawler/image-20240422170700595.png" class="" title="image-20240422170700595"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Crawl-delay: <span class="hljs-number">5</span> 指定爬虫访问间隔为<span class="hljs-number">5</span>秒<br></code></pre></td></tr></table></figure><p>注意事项</p><ol><li>不要禁止爬虫爬取网站的所有，因为从经验来看，如果屏蔽一次，解封后好一段时间爬虫都不会来你网站，收录成为问题。</li><li>代码后需要【冒号+空格+斜杆】 ，比如“Disallow: /<em>?</em> ”</li><li>当网站为静态路径时，需要屏蔽掉所有动态链接。网站中存在一种链接被收录即可，避免一个页面2个链接。代码如下“Disallow: /<em>?</em> ”表示禁止所有带 ?号的网址被爬取。通常动态网址带有“?”“=”等。</li><li>根据自己网站情况定，屏蔽不需要收录的网址。</li></ol><h1 id="伪装策略"><a href="#伪装策略" class="headerlink" title="伪装策略"></a>伪装策略</h1><p>我们知道即使是一些规模很小的网站通常也会对来访者的身份做一下检查，如验证请求 Headers，而对于那些上了一定规模的网站就更不用说了。因此，为了让我们的爬虫能够成功爬取所需数据信息，我们需要让爬虫进行伪装，简单来说就是让爬虫的行为变得像普通用户访问一样。</p><h2 id="Request-Headers问题"><a href="#Request-Headers问题" class="headerlink" title="Request Headers问题"></a>Request Headers问题</h2><img src="/2024/04/22/20240422_crawler/image-20240424001733029.png" class="" title="image-20240424001733029"><p>在上图中，我们可以看到 Request Headers 中包含 Referer 和 User-Agent 两个属性信息，Referer 的作用是告诉服务器该网页是从哪个页面链接过来的，User-Agent 中文是用户代理，它是一个特殊字符串头，作用是让服务器能够识别用户使用的操作系统、CPU 类型、浏览器等信息。通常的处理策略是：1）对于要检查 Referer 的网站就加上；2）对于每个 request 都添加 User-Agent。</p><h2 id="IP限制问题"><a href="#IP限制问题" class="headerlink" title="IP限制问题"></a>IP限制问题</h2><p>有时我们可能会对一些网站进行长期或大规模的爬取，而我们在爬取时基本不会变换 IP，有的网站可能会监控一个 IP 的访问频率和次数，一但超过这个阈值，就可能认作是爬虫，从而对其进行了屏蔽，对于这种情况，我们要采取间歇性访问的策略。</p><p>通常我们爬取是不会变换 IP 的，但有时可能会有一些特殊情况，要长时间不间断对某网站进行爬取，这时我们就可能需要采用 IP 代理的方式，但这种方式一般会增加我们开销，也就是可能要多花钱。</p><h1 id="Requests库"><a href="#Requests库" class="headerlink" title="Requests库"></a>Requests库</h1><p>所谓爬虫就是模拟客户端发送网络请求，获取网络响应，并按照一定的规则解析获取的数据并保存的程序。要说 Python 的爬虫必然绕不过 Requests 库。</p><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">Requests 唯一的一个非转基因的 Python HTTP 库，人类可以安全享用。警告：非专业使用其他 HTTP 库会导致危险的副作用，包括：安全缺陷症、冗余代码症、重新发明轮子症、啃文档症、抑郁、头疼、甚至死亡。<br>这个介绍还是比较生动形象的，便不再多说。安装使用终端命令 `pip install requests` 。<br></code></pre></td></tr></table></figure><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>导入 Requests 模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br></code></pre></td></tr></table></figure><p>获取网页：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">r = requests.get(<span class="hljs-string">&#x27;http://xxx.xxx&#x27;</span>)<br></code></pre></td></tr></table></figure><p>此时，我们获取了 Response 对象 r，我们可以通过 r 获取所需信息。Requests 简便的 API 意味着所有 HTTP 请求类型都是显而易见的，我们来看一下使用常见 HTTP 请求类型 get、post、put、delete 的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">r = requests.head(<span class="hljs-string">&#x27;http://xxx.xxx/get&#x27;</span>)<br>r = requests.post(<span class="hljs-string">&#x27;http://xxx.xxx/post&#x27;</span>, data = &#123;<span class="hljs-string">&#x27;key&#x27;</span>:<span class="hljs-string">&#x27;value&#x27;</span>&#125;)<br>r = requests.put(<span class="hljs-string">&#x27;http://xxx.xxx/put&#x27;</span>, data = &#123;<span class="hljs-string">&#x27;key&#x27;</span>:<span class="hljs-string">&#x27;value&#x27;</span>&#125;)<br>r = requests.delete(<span class="hljs-string">&#x27;http://xxx.xxx/delete&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通常我们会设置请求的超时时间，Requests 使用 <code>timeout</code> 参数来设置，单位是秒，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">r = requests.head(<span class="hljs-string">&#x27;http://xxx.xxx/get&#x27;</span>, timeout=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在使用 get 方式发送请求时，我们会将键值对形式参数放在 URL 中问号的后面，如：<code>http://xxx.xxx/get?key=val</code> ，Requests 通过 params 关键字，以一个字符串字典来提供这些参数。比如要传 <code>key1=val1</code> 和 <code>key2=val2</code> 到 <code>http://xxx.xxx/get</code>，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pms= &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;val1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;val2&#x27;</span>&#125;<br>r = requests.get(<span class="hljs-string">&quot;http://xxx.xxx/get&quot;</span>, params=pms)<br></code></pre></td></tr></table></figure><p>Requests 还允许将一个列表作为值传入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pms= &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;val1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: [<span class="hljs-string">&#x27;val2&#x27;</span>, <span class="hljs-string">&#x27;val3&#x27;</span>]&#125;<br></code></pre></td></tr></table></figure><p><strong><code>注</code></strong>：字典里值为 None 的键都不会被添加到 URL 的查询字符串里。</p><h3 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h3><p>我们来获取一下服务器的响应内容，这里地址 <code>https://api.github.com</code> 为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>r = requests.get(<span class="hljs-string">&#x27;https://api.github.com&#x27;</span>)<br><span class="hljs-built_in">print</span>(r.text)<br><br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-comment"># &#123;&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;current_user...</span><br></code></pre></td></tr></table></figure><p>当访问 r.text 之时，Requests 会使用其推测的文本编码，我们可以使用 <code>r.encoding</code> 查看其编码，也可以修改编码，如：<code>r.encoding = &#39;GBK&#39;</code>，当改变了编码，再次访问 r.text 时，Request 都将会使用 r.encoding 的新值。</p><ol><li><p>二进制响应内容 比如当我们要获取一张图片的数据，会以二进制的方式获取响应数据，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO<br>r = requests.get(<span class="hljs-string">&#x27;https://mp.weixin.qq.com/mp/qrcode?scene=10000004&amp;size=102&amp;__biz=MzU3Mzk1ODA5OQ==&amp;mid=2247483907&amp;idx=1&amp;sn=0e2bcd8811313327582623246795a26e&amp;send_time=&#x27;</span>)<br>i = Image.<span class="hljs-built_in">open</span>(BytesIO(r.content))<br><span class="hljs-built_in">print</span>(i)<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-comment">#&lt;PIL.BmpImagePlugin.BmpImageFile image mode=L size=129x129 at 0x22B7A7A8510&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>JSON响应内容 Requests 中已经内置了 JSON 解码器，因此我们可以很容易的对 JSON 数据进行解析，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>r = requests.get(<span class="hljs-string">&#x27;https://api.github.com&#x27;</span>)<br>r.json()<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-comment">#&#123;&#x27;current_user_url&#x27;: &#x27;https://api.github.com/user&#x27;, &#x27;current_user_authorizations_html_url&#x27;: &#x27;https://github.com/settings/connections/applications&#123;/client_id&#125;&#x27;, &#x27;authorizations_url&#x27;: &#x27;https://api.github.com/authorizations&#x27;, &#x27;code_search_url&#x27;: &#x27;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;, &#x27;commit_search_url&#x27;: &#x27;https://api.github.com/search/commits?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&#x27;,</span><br>......<br></code></pre></td></tr></table></figure><p><strong><code>注</code></strong>:成功调用 r.json() 并不一定响应成功，有的服务器会在失败的响应中包含一个 JSON 对象（比如 HTTP 500 的错误细节），这时我们就需要查看响应的状态码了 <code>r.status_code</code> 或 r.raise_for_status()，成功调用时 <code>r.status_code</code> 为 200，r.raise_for_status() 为 None。</p></li></ol><h3 id="自定义请求头"><a href="#自定义请求头" class="headerlink" title="自定义请求头"></a>自定义请求头</h3><p>当我们要给请求添加 headers 时，只需给 <code>headers</code> 参数传递一个字典即可，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://xxx.xxx&#x27;</span><br>hds= &#123;<span class="hljs-string">&#x27;user-agent&#x27;</span>: <span class="hljs-string">&#x27;xxx&#x27;</span>&#125;<br>r = requests.get(url, headers=hds)<br></code></pre></td></tr></table></figure><p><code>注</code>：自定义 headers 优先级是低于一些特定的信息的，如：在 <code>.netrc</code> 中设置了用户认证信息，使用 headers 设置的授权就不会生效，而当设置了 <code>auth</code> 参数，<code>.netrc</code> 的设置会无效。所有的 headers 值必须是 string、bytestring 或者 unicode，通常不建议使用 unicode。</p><h3 id="重定向与历史"><a href="#重定向与历史" class="headerlink" title="重定向与历史"></a>重定向与历史</h3><p>默认情况下，Requests 会自动处理除了 HEAD 以外的所有重定向，可以使用响应对象的 <code>history</code> 属性来追踪重定向，其返回为响应对象列表，这个列表是按照请求由晚到早进行排序的，看一下示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>r = requests.get(<span class="hljs-string">&#x27;http://github.com&#x27;</span>)<br><span class="hljs-built_in">print</span>(r.history)<br><br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-comment"># [&lt;Response [301]&gt;]</span><br></code></pre></td></tr></table></figure><p>如果使用的是get、post、put、delete、options、patch 可以使用 <code>allow_redirects</code> 参数禁用重定向。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">r = requests.get(<span class="hljs-string">&#x27;http://xxx.xxx&#x27;</span>, allow_redirects=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h3 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h3><p>当遇到网络问题（如：DNS 查询失败、拒绝连接等）时，Requests 会抛出 ConnectionError 异常；在 HTTP 请求返回了不成功的状态码时， Response.raise_for_status() 会抛出 HTTPError 异常；请求超时，会抛出 Timeout 异常；请求超过了设定的最大重定向次数，会抛出 TooManyRedirects 异常。所有 Requests 显式抛出的异常都继承自 requests.exceptions.RequestException。</p><h1 id="BeautifulSoup库"><a href="#BeautifulSoup库" class="headerlink" title="BeautifulSoup库"></a>BeautifulSoup库</h1><p>BeautifulSoup 是一个可以从 HTML 或 XML 文件中提取数据的 Python 库，它能够将 HTML 或 XML 转化为可定位的树形结构，并提供了导航、查找、修改功能，它会自动将输入文档转换为 Unicode 编码，输出文档转换为 UTF-8 编码。</p><p>BeautifulSoup 支持 Python 标准库中的 HTML 解析器和一些第三方的解析器，默认使用 Python 标准库中的 HTML 解析器，默认解析器效率相对比较低，如果需要解析的数据量比较大或比较频繁，推荐使用更强、更快的 lxml 解析器。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="BeautifulSoup-安装"><a href="#BeautifulSoup-安装" class="headerlink" title="BeautifulSoup 安装"></a><strong>BeautifulSoup 安装</strong></h3><p>如果使用 Debain 或 ubuntu 系统，可以通过系统的软件包管理来安装：<code>apt-get install Python-bs4</code>，如果无法使用系统包管理安装，可以使用 <code>pip install beautifulsoup4</code> 来安装。</p><h3 id="第三方解析器安装"><a href="#第三方解析器安装" class="headerlink" title="第三方解析器安装"></a><strong>第三方解析器安装</strong></h3><p>如果需要使用第三方解释器 lxml 或 html5lib，可是使用如下命令进行安装：<code>apt-get install Python-lxml(html5lib)</code> 和 <code>pip install lxml(html5lib)</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">解析器</th><th style="text-align:center"><strong>使用方法</strong></th><th style="text-align:center"><strong>优势</strong></th><th style="text-align:center"><strong>劣势</strong></th></tr></thead><tbody><tr><td style="text-align:center">Python标准库</td><td style="text-align:center">BeautifulSoup(markup,”html.parser”)</td><td style="text-align:center">Python的内置标准库；执行速度适中；文档容错能力强。</td><td style="text-align:center">Python 2.7.3 or 3.2.2前的版本中文档容错能力差。</td></tr><tr><td style="text-align:center">lxml HTML 解析器</td><td style="text-align:center">BeautifulSoup(markup,”lxml”)</td><td style="text-align:center">速度快；文档容错能力强。</td><td style="text-align:center">需要安装C语言库。</td></tr><tr><td style="text-align:center">lxml XML 解析器</td><td style="text-align:center"><code>BeautifulSoup(markup,[&quot;lxml-xml&quot;])``BeautifulSoup(markup,&quot;xml&quot;)</code></td><td style="text-align:center">速度快；唯一支持XML的解析器。</td><td style="text-align:center">需要安装C语言库</td></tr><tr><td style="text-align:center">html5lib</td><td style="text-align:center"><code>BeautifulSoup(markup,&quot;html5lib&quot;)</code></td><td style="text-align:center">最好的容错性；以浏览器的方式解析文档；生成HTML5格式的文档。</td><td style="text-align:center">速度慢；不依赖外部扩展。</td></tr></tbody></table></div><h2 id="快速上手-1"><a href="#快速上手-1" class="headerlink" title="快速上手"></a>快速上手</h2><p>将一段文档传入 BeautifulSoup 的构造方法，就能得到一个文档的对象，可以传入一段字符串或一个文件句柄，示例如下：</p><p><strong>index.html文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">html = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-string">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="hljs-string">&lt;head&gt;</span><br><span class="hljs-string">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="hljs-string">    &lt;title&gt;BeautifulSoup学习&lt;/title&gt;</span><br><span class="hljs-string">&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">Hello BeautifulSoup</span><br><span class="hljs-string">&lt;/body&gt;</span><br><span class="hljs-string">&lt;/html&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>使用示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-comment">#使用默认解析器</span><br>soup = BeautifulSoup(html,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><span class="hljs-comment">#使用 lxml 解析器</span><br>soup = BeautifulSoup(html,<span class="hljs-string">&#x27;lxml&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>举例本地文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-comment">#使用默认解析器</span><br>soup = BeautifulSoup(html,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><span class="hljs-comment">#使用 lxml 解析器</span><br>soup = BeautifulSoup(html,<span class="hljs-string">&#x27;lxml&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="对象的种类"><a href="#对象的种类" class="headerlink" title="对象的种类"></a>对象的种类</h2><p>BeautifulSoup 将 HTML 文档转换成一个树形结构，每个节点都是 Python 对象，所有对象可以归纳为4种：<code>Tag</code>，<code>NavigableString</code>，<code>BeautifulSoup</code>，<code>Comment</code>。</p><h3 id="Tag-对象"><a href="#Tag-对象" class="headerlink" title="Tag 对象"></a><strong>Tag 对象</strong></h3><p>Tag 对象与 HTML 或 XML 原生文档中的 tag 相同，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;title&gt;BeautifulSoup学习&lt;/title&gt;&#x27;</span>,<span class="hljs-string">&#x27;lxml&#x27;</span>)<br>tag = soup.title<br>tp =<span class="hljs-built_in">type</span>(tag)<br><span class="hljs-built_in">print</span>(tag)<br><span class="hljs-built_in">print</span>(tp)<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&lt;title&gt;BeautifulSoup学习&lt;/title&gt;</span><br><span class="hljs-string">&lt;class &#x27;bs4.element.Tag&#x27;&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>Tag 有很多方法和属性，这里先看一下它的的两种常用属性：<code>name</code> 和 <code>attributes</code>。</p><p>我们可以通过 <code>.name</code> 来获取 tag 的名字，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;title&gt;BeautifulSoup学习&lt;/title&gt;&#x27;</span>,<span class="hljs-string">&#x27;lxml&#x27;</span>)<br>tag = soup.title<br><span class="hljs-built_in">print</span>(tag.name)<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-comment">#title</span><br></code></pre></td></tr></table></figure><p>我们还可以修改 tag 的 name，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tag.name = <span class="hljs-string">&#x27;title1&#x27;</span><br><span class="hljs-built_in">print</span>(tag)<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-comment">#&lt;title1&gt;BeautifulSoup学习&lt;/title1&gt;</span><br></code></pre></td></tr></table></figure><p>一个 tag 可能有很多个属性，先看一它的 <code>class</code> 属性，其属性的操作方法与字典相同，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;title class=&quot;tl&quot;&gt;BeautifulSoup学习&lt;/title&gt;&#x27;</span>,<span class="hljs-string">&#x27;lxml&#x27;</span>)<br>tag = soup.title<br>cls = tag[<span class="hljs-string">&#x27;class&#x27;</span>]<br><span class="hljs-built_in">print</span>(cls)<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-comment">#[&#x27;tl&#x27;]</span><br></code></pre></td></tr></table></figure><p>我们还可以使用 <code>.attrs</code> 来获取，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ats = tag.attrs<br><span class="hljs-built_in">print</span>(ats)<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-comment">#&#123;&#x27;class&#x27;: [&#x27;tl&#x27;]&#125;</span><br></code></pre></td></tr></table></figure><p>tag 的属性可以被添加、修改和删除，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#添加 id 属性</span><br>tag[<span class="hljs-string">&#x27;id&#x27;</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-comment">#修改 class 属性</span><br>tag[<span class="hljs-string">&#x27;class&#x27;</span>] = <span class="hljs-string">&#x27;tl1&#x27;</span><br><br><span class="hljs-comment">#删除 class 属性</span><br><span class="hljs-keyword">del</span> tag[<span class="hljs-string">&#x27;class&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="NavigableString-对象"><a href="#NavigableString-对象" class="headerlink" title="NavigableString 对象"></a><strong>NavigableString 对象</strong></h3><p>NavigableString 类是用来包装 tag 中的字符串内容的，使用 <code>.string</code> 来获取字符串内容，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = tag.string<br></code></pre></td></tr></table></figure><p>可以使用 <code>replace_with()</code> 方法将原有字符串内容替换成其它内容 ，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tag.string.replace_with(<span class="hljs-string">&#x27;BeautifulSoup&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="BeautifulSoup-对象"><a href="#BeautifulSoup-对象" class="headerlink" title="BeautifulSoup 对象"></a><strong>BeautifulSoup 对象</strong></h3><p>BeautifulSoup 对象表示的是一个文档的全部内容，它并不是真正的 HTML 或 XML 的 tag，因此它没有 <code>name</code> 和 <code>attribute</code> 属性，为方便查看它的 <code>name</code> 属性，BeautifulSoup 对象包含了一个值为 <code>[document]</code> 的特殊属性 <code>.name</code>，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;title class=&quot;tl&quot;&gt;BeautifulSoup学习&lt;/title&gt;&#x27;</span>,<span class="hljs-string">&#x27;lxml&#x27;</span>)<br><span class="hljs-built_in">print</span>(soup.name)<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-comment">#[document]</span><br></code></pre></td></tr></table></figure><h3 id="Comment-对象"><a href="#Comment-对象" class="headerlink" title="Comment 对象"></a><strong>Comment 对象</strong></h3><p>Comment 对象是一个特殊类型的 NavigableString 对象，它会使用特殊的格式输出，看一下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;title class=&quot;tl&quot;&gt;Hello BeautifulSoup&lt;/title&gt;&#x27;</span>,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>comment = soup.title.prettify()<br><span class="hljs-built_in">print</span>(comment)<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&lt;title class=&quot;tl&quot;&gt;</span><br><span class="hljs-string"> Hello BeautifulSoup</span><br><span class="hljs-string">&lt;/title&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>我们前面看的例子中 tag 中的字符串内容都不是注释内容，现在将字符串内容换成注释内容，我们来看一下效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;title class=&quot;tl&quot;&gt;&lt;!--Hello BeautifulSoup--&gt;&lt;/title&gt;&#x27;</span>,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><span class="hljs-built_in">str</span> = soup.title.string<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-comment">#Hello BeautifulSoup</span><br></code></pre></td></tr></table></figure><p>通过结果我们发现注释符号 <code>&lt;!----&gt;</code> 被自动去除了，这一点我们要注意一下。</p><h2 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a><strong>搜索文档树</strong></h2><p>BeautifulSoup 定义了很多搜索方法。</p><p><strong>find_all()</strong></p><p>find_all() 方法搜索当前 tag 的所有 tag 子节点，方法详细如下：<code>find_all(name=None, attrs=&#123;&#125;, recursive=True, text=None,limit=None, **kwargs)</code>，来具体看一下各个参数。</p><p><code>name</code> 参数可以查找所有名字为 <code>name</code> 的 tag，字符串对象会被自动忽略掉，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;title class=&quot;tl&quot;&gt;Hello BeautifulSoup&lt;/title&gt;&#x27;</span>,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><span class="hljs-built_in">print</span>(soup.find_all(<span class="hljs-string">&#x27;title&#x27;</span>))<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-comment">#[&lt;title class=&quot;tl&quot;&gt;Hello BeautifulSoup&lt;/title&gt;]</span><br></code></pre></td></tr></table></figure><p><code>attrs</code> 参数定义一个字典参数来搜索包含特殊属性的 tag，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;title class=&quot;tl&quot;&gt;Hello BeautifulSoup&lt;/title&gt;&#x27;</span>,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>soup.find_all(attrs=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;tl&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p>调用 find_all() 方法时，默认会检索当前 tag 的所有子孙节点，通过设置参数 <code>recursive=False</code>，可以只搜索 tag 的直接子节点，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello BeautifulSoup&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;&#x27;</span>,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><span class="hljs-built_in">print</span>(soup.find_all(<span class="hljs-string">&#x27;title&#x27;</span>,recursive=<span class="hljs-literal">False</span>))<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-comment">#[]</span><br></code></pre></td></tr></table></figure><p>通过 <code>text</code> 参数可以搜搜文档中的字符串内容，它接受字符串、正则表达式、列表、True，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> re<br><br>soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;head&gt;myHead&lt;/head&gt;&lt;title&gt;BeautifulSoup&lt;/title&gt;&#x27;</span>,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><span class="hljs-comment">#字符串</span><br>soup.find_all(text=<span class="hljs-string">&#x27;BeautifulSoup&#x27;</span>)<br><span class="hljs-comment">#[&#x27;BeautifulSoup&#x27;]</span><br><br><span class="hljs-comment">#正则表达式</span><br>soup.find_all(soup.find_all(text=re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;title&#x27;</span>)))<br><span class="hljs-comment">#[&lt;head&gt;myHead&lt;/head&gt;, &lt;title&gt;BeautifulSoup&lt;/title&gt;]</span><br><br><span class="hljs-comment">#列表</span><br>soup.find_all(soup.find_all(text=[<span class="hljs-string">&#x27;head&#x27;</span>,<span class="hljs-string">&#x27;title&#x27;</span>]))<br><span class="hljs-comment">#[&lt;head&gt;myHead&lt;/head&gt;, &lt;title&gt;BeautifulSoup&lt;/title&gt;]</span><br><br><span class="hljs-comment">#True</span><br>soup.find_all(text=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">#[&#x27;myHead&#x27;, &#x27;BeautifulSoup&#x27;]</span><br></code></pre></td></tr></table></figure><p><code>limit</code> 参数与 SQL 中的 <code>limit</code> 关键字类似，用来限制搜索的数据，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;a id=&quot;link1&quot; href=&quot;http://example.com/elsie&quot;&gt;Elsie&lt;/a&gt;&lt;a id=&quot;link2&quot; href=&quot;http://example.com/elsie&quot;&gt;Elsie&lt;/a&gt;&#x27;</span>,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>soup.find_all(<span class="hljs-string">&#x27;a&#x27;</span>, limit=<span class="hljs-number">1</span>)<br><span class="hljs-comment">#[&lt;a href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure><p>我们经常见到 Python 中 <code>*arg</code> 和 <code>**kwargs</code> 这两种可变参数，<code>*arg</code> 表示非键值对的可变数量的参数，将参数打包为 tuple 传递给函数；<code>**kwargs</code> 表示关键字参数，参数是键值对形式的，将参数打包为 dict 传递给函数。</p><p>使用多个指定名字的参数可以同时过滤 tag 的多个属性，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;a id=&quot;link1&quot; href=&quot;http://example.com/elsie&quot;&gt;Elsie&lt;/a&gt;&lt;a id=&quot;link2&quot; href=&quot;http://example.com/elsie&quot;&gt;Elsie&lt;/a&gt;&#x27;</span>,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>soup.find_all(href=re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&quot;elsie&quot;</span>),<span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;link1&#x27;</span>)<br><span class="hljs-comment">#[&lt;a href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure><p>有些 tag 属性在搜索不能使用，如 HTML5 中的 <code>data-*</code> 属性，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;&#x27;</span>)<br>soup.find_all(data-foo=<span class="hljs-string">&#x27;value&#x27;</span>)<br></code></pre></td></tr></table></figure><p>首先当我在 Pycharm 中输入 <code>data-foo=&#39;value&#39;</code> 便提示语法错误了，然后我不管提示直接执行提示 <code>SyntaxError: keyword can&#39;t be an expression</code> 这个结果也验证了 <code>data-*</code> 属性在搜索中不能使用。我们可以通过 find_all() 方法的 <code>attrs</code> 参数定义一个字典参数来搜索包含特殊属性的 tag，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(soup.find_all(attrs=&#123;<span class="hljs-string">&#x27;data-foo&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>&#125;))<br><span class="hljs-comment"># [&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;]</span><br></code></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find()"></a><strong>find()</strong></h3><p>方法详细如下：<code>find(name=None, attrs=&#123;&#125;, recursive=True, text=None,**kwargs)</code>，我们可以看出除了少了 <code>limit</code> 参数，其它参数与方法 <code>find_all</code> 一样，不同之处在于：find_all() 方法的返回结果是一个列表，find() 方法返回的是第一个节点，find_all() 方法没有找到目标是返回空列表，find() 方法找不到目标时，返回 None。来看个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;a id=&quot;link1&quot; href=&quot;http://example.com/elsie&quot;&gt;Elsie&lt;/a&gt;&lt;a id=&quot;link2&quot; href=&quot;http://example.com/elsie&quot;&gt;Elsie&lt;/a&gt;&#x27;</span>,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><span class="hljs-built_in">print</span>(soup.find_all(<span class="hljs-string">&#x27;a&#x27;</span>, limit=<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(soup.find(<span class="hljs-string">&#x27;a&#x27;</span>))<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[&lt;a href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span><br><span class="hljs-string">&lt;a href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>从示例中我们也可以看出，find() 方法返回的是找到的第一个节点。</p><h3 id="find-parents-和-find-parent"><a href="#find-parents-和-find-parent" class="headerlink" title="find_parents() 和 find_parent()"></a><strong>find_parents() 和 find_parent()</strong></h3><p>find_all() 和 find() 用来搜索当前节点的所有子节点，find_parents() 和 find_parent() 则用来搜索当前节点的父辈节点。</p><h3 id="find-next-siblings-和-find-next-sibling"><a href="#find-next-siblings-和-find-next-sibling" class="headerlink" title="find_next_siblings() 和 find_next_sibling()"></a><strong>find_next_siblings() 和 find_next_sibling()</strong></h3><p>这两个方法通过 .next_siblings 属性对当前 tag 所有后面解析的兄弟 tag 节点进行迭代，find_next_siblings() 方法返回所有符合条件的后面的兄弟节点，find_next_sibling() 只返回符合条件的后面的第一个tag节点。</p><h3 id="find-previous-siblings-和-find-previous-sibling"><a href="#find-previous-siblings-和-find-previous-sibling" class="headerlink" title="find_previous_siblings() 和 find_previous_sibling()"></a><strong>find_previous_siblings() 和 find_previous_sibling()</strong></h3><p>这两个方法通过 .previous_siblings 属性对当前 tag 前面解析的兄弟 tag 节点进行迭代，find_previous_siblings() 方法返回所有符合条件的前面的兄弟节点，find_previous_sibling() 方法返回第一个符合条件的前面的兄弟节点。</p><h3 id="find-all-next-和-find-next"><a href="#find-all-next-和-find-next" class="headerlink" title="find_all_next() 和 find_next()"></a><strong>find_all_next() 和 find_next()</strong></h3><p>这两个方法通过 .next_elements 属性对当前 tag 之后的 tag 和字符串进行迭代，find_all_next() 方法返回所有符合条件的节点，find_next() 方法返回第一个符合条件的节点。</p><h3 id="find-all-previous-和-find-previous"><a href="#find-all-previous-和-find-previous" class="headerlink" title="find_all_previous() 和 find_previous()"></a><strong>find_all_previous() 和 find_previous()</strong></h3><p>这两个方法通过 .previous_elements 属性对当前节点前面的 tag 和字符串进行迭代，find_all_previous() 方法返回所有符合条件的节点，find_previous() 方法返回第一个符合条件的节点。</p><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a><strong>CSS选择器</strong></h2><p>BeautifulSoup 支持大部分的 CSS 选择器，在 Tag 或 BeautifulSoup 对象的 .select() 方法中传入字符串参数，即可使用 CSS 选择器的语法找到 tag，返回类型为列表。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;body&gt;&lt;a id=&quot;link1&quot; class=&quot;elsie&quot;&gt;Elsie&lt;/a&gt;&lt;a id=&quot;link2&quot; class=&quot;elsie&quot;&gt;Elsie&lt;/a&gt;&lt;/body&gt;&#x27;</span>,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><span class="hljs-built_in">print</span>(soup.select(<span class="hljs-string">&#x27;a&#x27;</span>))<br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-comment">#[&lt;a clss=&quot;elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;, &lt;a clss=&quot;elsie&quot; id=&quot;link2&quot;&gt;Elsie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure><p>通过标签逐层查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&#x27;body a&#x27;</span>)<br></code></pre></td></tr></table></figure><p>找到某个 tag 标签下的直接子标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&#x27;body &gt; a&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通过类名查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&#x27;.elsie&#x27;</span>)<br>soup.select(<span class="hljs-string">&#x27;[class~=elsie]&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通过 id 查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&#x27;#link1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>使用多个选择器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&#x27;#link1,#link2&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通过属性查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&#x27;a[class]&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通过属性的值来查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&#x27;a[class=&quot;elsie&quot;]&#x27;</span>)<br></code></pre></td></tr></table></figure><p>查找元素的第一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.select_one(<span class="hljs-string">&#x27;.elsie&#x27;</span>)<br></code></pre></td></tr></table></figure><p>查找兄弟节点标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#查找所有</span><br>soup.select(<span class="hljs-string">&#x27;#link1 ~ .elsie&#x27;</span>)<br><span class="hljs-comment">#查找第一个</span><br>soup.select(<span class="hljs-string">&#x27;#link1 + .elsie&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>数据分析</category>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行走</title>
    <link href="/2024/04/22/20240422_dailyTalks/"/>
    <url>/2024/04/22/20240422_dailyTalks/</url>
    
    <content type="html"><![CDATA[<h1 id="行走"><a href="#行走" class="headerlink" title="行走"></a>行走</h1><p>240414到东莞，找了淇本打算找份短期工打，时间冲突与学长交流240415当天进当天辞。</p><p>240416到广州，到焕的私影住到240420，期间见了辉、城、山等人。</p><p>240422到广州，到大姐夫那住了一晚。</p><p>240421到深圳，和表哥堂哥和一个弟弟约了个饭。</p><p>240422到深圳，到堂伯公司住，和细姐堂哥吃了个饭。</p><p>240423在深圳，和锐、艳、伟吃饭。</p><p>240424在深圳，和伟去深大逛了一圈。</p><p>240425在深圳，晚上和甲鱼晚上聊了近况。</p><p>240426在深圳，和挺聊了他的轨迹。</p><p>240427在深圳，下午和艺逛了很久。</p><p>240428回汕头。</p><p>240504-06在汕头，和洪逛了汕头。</p><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><p>0415    i人？组织与准备没做好，“你好像没有做好准备”“….”，不自在的模样。经验太少，不知道用什么姿态去待不同的人，准备不充分，做不到落落大方。</p><p>0416    细节。对待人的时候一些细节没到位，当别人问自己为什么反应不过来时，“你们真好呀”。</p><p>0417    反思与内耗。大多数时候我生怕太过于高傲或太过于自卑，与人接触小心翼翼，反思是好事，但内耗没必要，怎么解决呀，别人怎么处理。</p><p>0418    怕开端。及时走。</p><p>0422    遇到对等的人与不对等的人。什么姿态。</p><p>0423    注意一下外在形象。</p><p>0425    如何认识多一些厉害的人。艺术？兴趣爱好？</p><p>0426    如何规划好研究生生涯？</p><p>0427    找女朋友了吗？</p><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>见见不同的领域，看看朋友在做什么，怎么做，收获了什么，为什么能行，前景怎么样。</p><h2 id="电商？"><a href="#电商？" class="headerlink" title="电商？"></a>电商？</h2><p>淇，工作具体而言，通过1688平台，与厂家进行对接，沟通与服务，获取资源与进行运营，主要靠提成与开增值单。工作优点是获取一手厂家资源，做生意重要的是选品，即使工作不顺意，当自己有想法的时候可以开开店。</p><h2 id="微商？"><a href="#微商？" class="headerlink" title="微商？"></a>微商？</h2><p>通过各个平台收集信息，通过平台活动下单获取比较好的商品信息（需自己琢磨或收取一些同行信息），及时下单以及及时出手，出手获取比较好的利润差价。</p><h2 id="做平台？"><a href="#做平台？" class="headerlink" title="做平台？"></a>做平台？</h2><p>焕以前做一个校园内部外卖平台，最开始自己跑，后面人越来越多跑，接触的人多，协调跑手与客户的关系是比较考验人的，模式不容易被复制，当你做本校区的时候，需要负责人很投入很负责，而推广到其他校区，很难协调其他人的关系，别人也不会珍惜这个平台。</p><h2 id="短视频？"><a href="#短视频？" class="headerlink" title="短视频？"></a>短视频？</h2><h2 id="读研？"><a href="#读研？" class="headerlink" title="读研？"></a>读研？</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>为自己做事，有清楚的定位与长远的打算</p><ul><li>积累人脉，了解行业的最新动态，发现市场空白点并进行创业。</li><li>喜欢科研，在喜欢的领域深造，读博进阶。</li></ul><p>为自己做事，有清晰的职业规划</p><ul><li>锻炼好技能，实现技能的磨砺，未来成为不可替代型人才，领取高工资。（先赚了再说，后面别的想法再说）</li><li>进入体制，进行选调或考公，行稳致远。</li><li>进入国企，过好自己的小生活。</li></ul><p>不懂什么事</p><ul><li>大家都读，我也都读，不知道，随便，混了吧</li></ul><h2 id="实体店？"><a href="#实体店？" class="headerlink" title="实体店？"></a>实体店？</h2><p>焕搞了一个私人影院，有一些可以帮忙的朋友，灵活调动是很好的小团队，很好的笑容和很强的执行力，租金成本碰上疫情相对低了一些，很好的地段，比较好的关系网，还可以的方向，比较有逻辑的赚钱思维，热情大方做的不错。</p><h2 id="国企？"><a href="#国企？" class="headerlink" title="国企？"></a>国企？</h2><p>城在广州某国企，经常很闲经常思考生活的意义，对普通人来说一个月万把块钱稳定的工作，已经相当不错，公司不倒干到退休，在国企熬资历，如果没大志向，个人感觉小生活可以过的很好。</p><h2 id="公务员？"><a href="#公务员？" class="headerlink" title="公务员？"></a>公务员？</h2><p>哥在体制蛮多年了，一个弟弟也刚上岸。何为上岸，个人感觉是达到一定目标，实现一定跨越。是这样的，体制内稳定，有能力有魄力的人可以尝试上升实现理想，一般能力的人可以过好自己的生活。</p><h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><h3 id="作何"><a href="#作何" class="headerlink" title="作何"></a>作何</h3><p>直系师兄人非常好，给了现阶段的直接建议：</p><ol><li>提前学习前置知识，否则后面会很难受。</li><li>有空到处逛逛旅旅游，后面学习工作了就没时间玩。</li></ol>]]></content>
    
    
    <categories>
      
      <category>感悟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>成长</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TensorFlow_01</title>
    <link href="/2024/04/12/20240412_TensorFlow_01/"/>
    <url>/2024/04/12/20240412_TensorFlow_01/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>房价回归预测</title>
    <link href="/2024/04/12/20240412_housePrices/"/>
    <url>/2024/04/12/20240412_housePrices/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>样例</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析</title>
    <link href="/2024/04/12/20240412_dataAnalysis/"/>
    <url>/2024/04/12/20240412_dataAnalysis/</url>
    
    <content type="html"><![CDATA[<img src="/2024/04/12/20240412_dataAnalysis/image-20240412163256908.png" class="" title="image-20240412163256908">]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑回归</title>
    <link href="/2024/04/12/20240412_LogisticRegression/"/>
    <url>/2024/04/12/20240412_LogisticRegression/</url>
    
    <content type="html"><![CDATA[<img src="/2024/04/12/20240412_LogisticRegression/image-20240412163438609.png" class="" title="image-20240412163438609">]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在博客中渲染数学公式</title>
    <link href="/2024/04/12/20240412_AddMathToBlogs/"/>
    <url>/2024/04/12/20240412_AddMathToBlogs/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​        在博客写作过程中，经常需要往文章中插入数学公式，对于不熟悉LaTex语法的人来说，我们自然希望能使用<code>MathType</code>编辑公式，然后往文章中插入<code>LaTex</code>语法的公式即可。然而，如果使用<code>Hexo</code>部署博客，<code>Hexo</code>自带的默认渲染引擎<a href="https://link.zhihu.com/?target=https%3A//github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>无法渲染<code>LaTex</code>公式。</p><p>​        <a href="https://www.latexlive.com/##">在线LaTeX公式编辑器</a></p><h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><h2 id="hexo-math插件"><a href="#hexo-math插件" class="headerlink" title="hexo-math插件"></a>hexo-math插件</h2><p>​    首先，安装<a href="https://link.zhihu.com/?target=https%3A//github.com/hexojs/hexo-math">hexo-math</a>插件，该插件使用<code>MathJax/KaTex</code>来渲染数学公式:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> hexo-<span class="hljs-keyword">math</span> --save<br></code></pre></td></tr></table></figure><p>​    安装完成后，配置目录下的<code>_config.yml</code>，加入下面配置信息：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">math</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">engine</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;mathjax&#x27;</span><br>  <span class="hljs-attribute">mathjax</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">src</span><span class="hljs-punctuation">:</span> <span class="hljs-string">custom_mathjax_source</span><br>    <span class="hljs-attribute">config</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-comment"># MathJax config</span><br></code></pre></td></tr></table></figure><p>​    我在_config.主题.yml下还加了下面配置信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mathjax:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">cdn:</span> <span class="hljs-string">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span><br></code></pre></td></tr></table></figure><h2 id="更改Hexo渲染引擎"><a href="#更改Hexo渲染引擎" class="headerlink" title="更改Hexo渲染引擎"></a>更改Hexo渲染引擎</h2><p>​    更改<code>Hexo</code>的渲染引擎。将<code>Hexo</code>的默认渲染引擎是<code>hexo-renderer-marked</code>替换为<a href="https://link.zhihu.com/?target=https%3A//github.com/sun11/hexo-renderer-kramed">hexo-renderer-kramed</a>。之所以这么做，是因为<code>Hexo</code>默认渲染引擎会将$$$$之间的下划线 <code>_</code> 解析成<code>HTML</code>中的<code>&lt;i&gt;</code>。然而，在<code>LaTex</code>公式中，经常用下划线 <code>_</code> 表示下标，这就导致冲突。而<code>hexo-renderer-kramed</code>在<code>hexo-renderer-marked</code>基础上修改了这个Bug。在安装<code>hexo-renderer-kramed</code>之前，需要卸载<code>hexo-renderer-marked</code>，顺序执行以下两行命令完成卸载与安装：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm uninstall hexo-renderer-marked <span class="hljs-comment">--save</span><br>npm install hexo-renderer-kramed <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h2 id="解决语义冲突"><a href="#解决语义冲突" class="headerlink" title="解决语义冲突"></a>解决语义冲突</h2><p>​    在markdown中，斜体用下划线<code>_</code>或星号<code>*</code>表示，而在<code>LaTex</code>中，下划线<code>_</code>表示下标。为了解决这个冲突，需要修改两处。在博客根目录下，进入<code>node_modules\kramed\lib\rules\inline.js</code>，修改第11行escape变量的值（这一步是在原基础上对<code>,&#123;,&#125;</code>的<code>转义(escape)</code>）：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs r">修改前：escape<span class="hljs-operator">:</span> <span class="hljs-operator">/</span><span class="hljs-operator">^</span><span class="hljs-punctuation">\</span><span class="hljs-punctuation">\</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">\</span><span class="hljs-punctuation">\</span>`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,<br>修改后：escape: /^\\([`<span class="hljs-operator">*</span><span class="hljs-punctuation">\</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">\</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-comment">#$+\-.!_&gt;])/,</span><br></code></pre></td></tr></table></figure><p>​    同时，把第20行的<code>em</code>变量也做相应的修改：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">修改前：em: /^\b_((?:<span class="hljs-emphasis">__|[\s\S])+?)_</span>\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,<br>修改后：em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,<br></code></pre></td></tr></table></figure><h2 id="博客开头mathjax开关"><a href="#博客开头mathjax开关" class="headerlink" title="博客开头mathjax开关"></a>博客开头mathjax开关</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br>  <span class="hljs-attr">title:</span> <span class="hljs-string">xxxxxxxxxxxxxxx</span><br>  <span class="hljs-attr">tags:</span> <span class="hljs-string">xxx</span><br>  <span class="hljs-attr">mathjax:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="公式单行居中"><a href="#公式单行居中" class="headerlink" title="公式单行居中"></a>公式单行居中</h2><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;%raw%&#125;</span><span class="language-xml"> $$evidence_</span><span class="hljs-template-variable">&#123;i&#125;</span><span class="language-xml">=\sum_</span><span class="hljs-template-variable">&#123;j&#125;</span><span class="language-xml">W_</span><span class="hljs-template-variable">&#123;ij&#125;</span><span class="language-xml">x_</span><span class="hljs-template-variable">&#123;j&#125;</span><span class="language-xml">+b_</span><span class="hljs-template-variable">&#123;i&#125;</span><span class="language-xml"> $$</span><span class="hljs-template-variable">&#123;% endraw %&#125;</span><br></code></pre></td></tr></table></figure> $$evidence_{i}=\sum_{j}W_{ij}x_{j}+b_{i} $$<h2 id="公式嵌入到句子中"><a href="#公式嵌入到句子中" class="headerlink" title="公式嵌入到句子中"></a><strong>公式嵌入到句子中</strong></h2><p>若想在一句话中<code>嵌入公式</code>，则只需要在<code>LaTex</code>公式两端用一个<code>$</code>，如：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">在公式<span class="hljs-variable">$ </span>evidence_&#123;i&#125;=\sum_&#123;j&#125;W_&#123;ij&#125;x_&#123;j&#125;+b_&#123;i&#125; <span class="hljs-variable">$中</span>，<span class="hljs-variable">$W</span>_i<span class="hljs-variable">$和</span><span class="hljs-variable">$b</span>_i<span class="hljs-variable">$分</span>别为类别的权值和偏置。<br></code></pre></td></tr></table></figure><p>在公式$evidence_{i}=\sum_{j}W_{ij}x_{j}+b_{i}$中，$W_i$和$b_i$分别为类别的权值和偏置。</p><h1 id="与MathType结合使用"><a href="#与MathType结合使用" class="headerlink" title="与MathType结合使用"></a><strong>与MathType结合使用</strong></h1><p>​    对于比较复杂的公式，如果不熟悉<code>LaTex</code>语法，直接写起来很麻烦，所以我尝试先使用<code>MathType</code>将公式写好，再复制公式，并以<code>LaTex</code>格式粘贴到markdown中。按照MathType<a href="https://link.zhihu.com/?target=https%3A//docs.wiris.com/en/mathtype/mathtype_desktop/mathjax%23write_equations_for_a_mathjax-enabled_website">官方教程</a>，对<code>Preferences</code>下的<code>Cut and Copy Preferences</code>进行设置。如下图：</p><img src="/2024/04/12/20240412_AddMathToBlogs/image-20240412012449378.png" class="" title="image-20240412012449378"><p>粘贴出现错误</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">INFO  [hexo-math] <span class="hljs-keyword">Using</span> engine <span class="hljs-comment">&#x27;mathjax&#x27;</span><br>INFO  Start processing<br>FATAL Something<span class="hljs-comment">&#x27;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br>Template render <span class="hljs-keyword">error</span>: (unknown path) [Line <span class="hljs-number">52</span>, Column <span class="hljs-number">56</span>]<br>  expected variable <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>​    解决，参考<a href="https://www.jianshu.com/p/738ebe02029b">Hexo的一个小BUG</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 、">在公式的前后分别加上&#123;% raw%&#125;和&#123;% endraw %&#125;:&#123;% raw%&#125; 数学公式 &#123;% endraw %&#125;<br></code></pre></td></tr></table></figure><p>​    具体地，如下所示：</p><ul><li><p>以<code>LaTex2.09 and later</code>或<code>MathJax:LaTex</code>方式粘贴:</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">&#123;% raw%&#125; \[&#123;x_&#123;1,2&#125;&#125; = \frac</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">-</span> b \pm \sqrt &#123;&#123;b^<span class="hljs-number">2</span>&#125; - <span class="hljs-number">4</span>ac&#125; &#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">2a</span>&#125;&#125;</span><span class="language-xml">\] &#123;% endraw %&#125;</span><br></code></pre></td></tr></table></figure><p>效果为：</p> \[{x_{1,2}} = \frac{{ - b \pm \sqrt {{b^2} - 4ac} }}{{2a}}\] </li><li><p>以Plain Tex方式粘贴：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">&#123;% raw%&#125; $$&#123;x_&#123;1,2&#125;&#125; = </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">-</span> b \pm \sqrt &#123;&#123;b^<span class="hljs-number">2</span>&#125; - <span class="hljs-number">4</span>ac&#125; &#125; \over &#123;<span class="hljs-number">2</span>a&#125;&#125;</span><span class="language-xml">$$ &#123;% endraw %&#125;</span><br></code></pre></td></tr></table></figure><p>效果为：</p> $${x_{1,2}} = {{ - b \pm \sqrt {{b^2} - 4ac} } \over {2a}}$$ </li><li><p>在句子中间粘贴：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">公式在句子中显示：&#123;% raw%&#125; $&#123;x_&#123;1,2&#125;&#125; = </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">-</span> b \pm \sqrt &#123;&#123;b^<span class="hljs-number">2</span>&#125; - <span class="hljs-number">4</span>ac&#125; &#125; \over &#123;<span class="hljs-number">2</span>a&#125;&#125;</span><span class="language-xml">$ &#123;% endraw %&#125;。</span><br></code></pre></td></tr></table></figure><p>效果为：</p><p>公式在句子中显示： ${x_{1,2}} = {{ - b \pm \sqrt {{b^2} - 4ac} } \over {2a}}$ 。</p></li></ul><h1 id="鸣谢博文"><a href="#鸣谢博文" class="headerlink" title="鸣谢博文"></a>鸣谢博文</h1><p><a href="https://zhuanlan.zhihu.com/p/108766968">结合MathType和MathJax在Hexo博客中插入数学公式 </a></p>]]></content>
    
    
    <categories>
      
      <category>搭建网站</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性回归</title>
    <link href="/2024/04/10/20240411_linearRegression/"/>
    <url>/2024/04/10/20240411_linearRegression/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>&emsp;&emsp;一个事物唯一由另一个事物决定</p><h2 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h2><p>&emsp;&emsp;类似二元直角坐标系，描出关系图形是一条直线，称为线性关系</p><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>&emsp;&emsp;回归分析是一种统计方法,于对具有一个或多个自变量的因变量(目标变量)和自变量(预测变量)之间的关系进行建模。具体地说，回归分析有助于我们理解在其他自变量保持固定的情况下，自变量的值对应于自变量的变化方式。它可以预测连续/实际值,例如温度,年龄,工资,价格等。</p><p>&emsp;&emsp;回归是一种<strong>有监督</strong>的学习技术，有助于<strong>发现变量之间的相关性</strong>,并使我们能够基于一个或多个预测变量来预测连续输出变量。它主要用于<strong>预测，时间序列建模以及确定变量之间的因果关系</strong>。</p><h1 id="简单线性回归模型"><a href="#简单线性回归模型" class="headerlink" title="简单线性回归模型"></a><strong>简单线性回归模型</strong></h1> $$\hat{y}= h(x) = w*x +b  $$<p>&emsp;&emsp;其中$w$叫权重参数，$b$叫偏置或者截距。当求解得到未知参数$w$，$b$之后，也就意味着我们得到了这个预测模型。假设给定一个房屋面积$x$，就能够预测出其对应的房价。</p><h2 id="求解线性回归模型"><a href="#求解线性回归模型" class="headerlink" title="求解线性回归模型"></a><strong>求解线性回归模型</strong></h2><p>&emsp;&emsp;当建立好一个模型后，自然而然想到的就是如何通过给定的数据，也叫训练集（Training Data），来对模型$h(x)$进行求解。在中学时期我们倒是学过如何通过两个坐标点来求解过这两点的直线，可在上述的场景中这种做法显然行不通的（因为所有的点并不在一条直线上），那有没有什么好的解决的办法呢？</p><p>&emsp;&emsp;此时就需要我们转换一下思路了，既然不能直接来进行求解那就换一种间接的方式。现在来想象一下，当$h(x)$满足一个什么样的条件时，它才能称得上是一个好的$h(x)$? 回想一下求解$h(x)$的目的是什么，不就是希望输入面积$x$后能够输出”准确”的房价$h(x)$吗 ？既然直接求解$h(x)$不好入手，那么我们就从“准确”来入手。</p><p>&emsp;&emsp;可又怎么来定义准确呢？在这里，我们可以通过计算每个样本的真实房价与预测房价之间的均方误差来对“准确”进行刻画</p> $$ J(w,b) = {1 \over 2m}  \sum_{i=1}^{m} \left ( y^{(i)} - \hat{y^(i)} \right ) ^2  $$ $$\hat{y}^{(i)} = h(x^{(i)}) = wx^{(i)}+b$$ <p>&emsp;&emsp;其中，$m$表示样本数数量$x^{(i)}$表示第$i$个样本的，也就是第$i$个房屋的面积；$y^{(i)}$表示第$i$个房屋的真实价格；$\hat{y}^{(i)}$表示第$i$个房屋的预测价格。</p><p>&emsp;&emsp;由式可知，当函数$J(w,b)$取最小值时的参数$\hat{w},\hat{b}$，就是要求的目标参数。为什么？因为当$J(w,b)$取最小值就意味着此时所有样本的预测值与真实值之间的误差（Error）最小。如果极端一点，那就是所有预测值都等同于真实值，此时的$J(w,b)$就是0了。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>&emsp;&emsp;因此，对于如何求解模型$h(x)$的问题就转换成了如何最小化函数$J(w,b)$的问题。而$J(w,b)$也有一个专门的术语叫目标函（Objective Function）或者是代价函数（Cost Function）亦或是<a href="https://www.zhihu.com/search?q=损失函数&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A2183691849}">损失函数</a>。</p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><img src="/2024/04/10/20240411_linearRegression/image-20240412221504247.png" class="" title="image-20240412221504247"><p><a href="https://zhuanlan.zhihu.com/p/80887841">图片来源</a></p><h1 id="样例与代码"><a href="#样例与代码" class="headerlink" title="样例与代码"></a>样例与代码</h1>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习</title>
    <link href="/2024/04/10/Python/"/>
    <url>/2024/04/10/Python/</url>
    
    <content type="html"><![CDATA[<h1 id="Python3教程"><a href="#Python3教程" class="headerlink" title="Python3教程 "></a><a href="https://www.runoob.com/python3/python3-tutorial.html">Python3教程 </a></h1>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>路线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo+GitHub搭建个人免费博客</title>
    <link href="/2024/04/09/20240409_github&amp;hexo/"/>
    <url>/2024/04/09/20240409_github&amp;hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="GitHub-Pages与Hexo"><a href="#GitHub-Pages与Hexo" class="headerlink" title="GitHub Pages与Hexo"></a>GitHub Pages与Hexo</h2><ul><li><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p></li><li><p>Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。</p></li><li><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。（注意，在GitHub上没有存储你的md文件）</p><img src="/2024/04/09/20240409_github&hexo/image-20240409225733759.png" class="" title="image-20240409225733759"></li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>输入代码时，核对准确，最好切换成英文输入法；</li><li>将文中的 “用户名” 和 “邮箱” 替换为自己的 GitHub 账户名和绑定的邮箱；</li><li>统一使用 Git Bash 进行操作（其实vscode控制台也可以，但是这样子真的好方便，以后就用typora写完直接hexo clean和hexo d就可以了）；</li><li>hhh小白请严格按步骤进行，不要跳！</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git</p><ul><li><a href="https://nodejs.org/zh-cn">Node.js</a></li><li><a href="https://git-scm.com/downloads">Git</a></li></ul><p>下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。</p><p>安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git —version 并回车，如下图出现程序版本号即可。</p><h1 id="连接GitHub"><a href="#连接GitHub" class="headerlink" title="连接GitHub"></a>连接GitHub</h1><ol><li><p>使用邮箱注册<a href="https://github.com/">GitHub</a>账户(在github官网)</p></li><li><p>右键 -&gt; Git Bash Here , 设置_用户名和邮箱_（在自己电脑，随便找个地方，因为是全局的）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;GitHub 用户名&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;GitHub 邮箱&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>创建 SSH 密匙</strong>：输入 <code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>，然后一路回车。获取生成了密钥。</p><p>（注意，如果不一直回车，自定义名称，则后面需要在。ssh后添加一个config文件，且内容为</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># github</span><br>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~<span class="hljs-regexp">/.ssh/</span>你的自定义名称<br></code></pre></td></tr></table></figure><p>）</p></li><li><p><strong>添加密匙：</strong></p><p>进入 [C:\Users\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p><p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p><p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p><img src="/2024/04/09/20240409_github&hexo/image-20240409232327677-1712911016461.png" class="" title="image-20240409232327677"></li><li><p><strong>验证连接：</strong></p><p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认</p></li></ol><h1 id="创建Github-Pages仓库"><a href="#创建Github-Pages仓库" class="headerlink" title="创建Github Pages仓库"></a>创建Github Pages仓库</h1><p>创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p><img src="/2024/04/09/20240409_github&hexo/image-20240409232820900.png" class="" title="image-20240409232820900"><h2 id="本地安装-Hexo-博客程序"><a href="#本地安装-Hexo-博客程序" class="headerlink" title="本地安装 Hexo 博客程序"></a>本地安装 Hexo 博客程序</h2><p> <a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a></p><p><a href="https://huangzxuan.github.io/2024/04/09/blog01/">如何选主题更换主题呀，例如我的fluid</a></p><h1 id="部署Hexo到GitHub-Pages"><a href="#部署Hexo到GitHub-Pages" class="headerlink" title="部署Hexo到GitHub Pages"></a>部署Hexo到GitHub Pages</h1><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p><p>首先<strong>安装 hexo-deployer-git</strong>：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>然后<strong>修改 _config.yml</strong> 文件末尾的 Deployment 部分，修改成如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> git@github.com:用户名/用户名.github.io.git<br><span class="hljs-symbol">  branch:</span> master（这里可能是main，看你github仓库的主要分支）<br></code></pre></td></tr></table></figure><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p><p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p>]]></content>
    
    
    <categories>
      
      <category>搭建网站</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于fluid</title>
    <link href="/2024/04/09/20240410_hexo/"/>
    <url>/2024/04/09/20240410_hexo/</url>
    
    <content type="html"><![CDATA[<p>一款 Material Design 风格的主题</p><h1 id="搭建-Hexo-博客"><a href="#搭建-Hexo-博客" class="headerlink" title="搭建 Hexo 博客"></a>搭建 Hexo 博客</h1><p>如果你还没有 Hexo 博客，请按照 <a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a> 进行安装、建站。</p><h1 id="获取主题最新版本"><a href="#获取主题最新版本" class="headerlink" title="获取主题最新版本"></a>获取主题最新版本</h1><p>方式一：<br>Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><br>然后在博客目录下创建 _config.fluid.yml，将主题的<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a>内容复制进去<br>方式二：<br>下载<a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新release</a>解压导themes目录，并解压出的文件夹命名为fluid</p><h1 id="指定主题"><a href="#指定主题" class="headerlink" title="指定主题"></a>指定主题</h1><p>如下修改 Hexo 博客目录中的 _config.yml：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid  <span class="hljs-meta"># 指定主题</span><br><br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN  <span class="hljs-meta"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure></p><h1 id="创建关于页"><a href="#创建关于页" class="headerlink" title="创建关于页"></a>创建关于页</h1><p>首次使用主题的「关于页」需要手动创建：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about<br></code></pre></td></tr></table></figure><br>创建成功后，编辑博客目录下 /source/about/index.md，添加 layout 属性。<br>修改后的文件示例如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure></p><h1 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a><a href="https://hexo.fluid-dev.com/docs/start/#%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%A2%98">更新主题</a></h1><h1 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h1><img src="/2024/04/09/20240410_hexo/image-20240410180425918.png" class="" title="image-20240410180425918">]]></content>
    
    
    <categories>
      
      <category>搭建网站</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
